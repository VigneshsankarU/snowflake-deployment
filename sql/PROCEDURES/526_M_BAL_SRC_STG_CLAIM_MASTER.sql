-- Object Type: PROCEDURES
CREATE OR REPLACE PROCEDURE ALFA_EDW_DEV.PUBLIC.M_BAL_SRC_STG_CLAIM_MASTER("RUN_ID" VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS ' DECLARE SRC_QUERY varchar;
CNT varchar;
TABLE_NM varchar;
PMMAPPINGNAME varchar;
ACT_PROJ_ID varchar;
BATCH_ACTIVE_IND varchar;
BEGIN 


-- PIPELINE START FOR 1

-- Component sq_TRG_CLAIM_MASTER_SRC, Type TABLE_DDL Creating an empty table
CREATE OR REPLACE TEMPORARY TABLE sq_TRG_CLAIM_MASTER
(
FILE_NAME varchar(13),
FREQUENCY varchar(6),
DATE varchar(13),
MRI_L_CNT varchar(12),
MRI_BLANK_CNT varchar(16),
MRI_C_CNT varchar(16),
MRI_D_CNT varchar(12),
MRI_A_CNT varchar(12),
MRI_V_CNT varchar(12),
MRI_TOTAL varchar(20),
FIELD11 varchar(12),
source_record_id number autoincrement start 1 increment 1
);


-- Component sq_TRG_CLAIM_MASTER_SRC, Type IMPORT_DATA Importing Data
;


-- PIPELINE START FOR 1

-- Component sq_STG_CLMF_CLM_NO_TRL, Type SOURCE 
CREATE OR REPLACE TEMPORARY TABLE sq_STG_CLMF_CLM_NO_TRL AS
(
SELECT /* adding column aliases to ensure proper downstream column references */
$1 as CLM_COUNT,
$2 as source_record_id
FROM (
SELECT SRC.*, row_number() over (order by 1) AS source_record_id FROM (
select 1
--SRC_QUERY
) SRC
)
);


-- Component exp_HOLD_DATA, Type EXPRESSION 
CREATE OR REPLACE TEMPORARY TABLE exp_HOLD_DATA AS
(
SELECT
1 as out_DUMMY_mstr,
CASE WHEN ( :CNT = ''C'' ) THEN TO_NUMBER(regexp_replace(sq_TRG_CLAIM_MASTER.MRI_C_CNT,''MRI C'','''',1,0,''i'')) ELSE TO_NUMBER(regexp_replace(sq_TRG_CLAIM_MASTER.MRI_A_CNT,''MRI A'','''',1,0,''i'')) END as out_MRI_CNT,
sq_TRG_CLAIM_MASTER.source_record_id
FROM
sq_TRG_CLAIM_MASTER
);


-- Component exp_HOLD_STAGING_DATA, Type EXPRESSION 
CREATE OR REPLACE TEMPORARY TABLE exp_HOLD_STAGING_DATA AS
(
SELECT
sq_STG_CLMF_CLM_NO_TRL.CLM_COUNT as CLM_COUNT,
1 as out_DUMMY_dtl,
sq_STG_CLMF_CLM_NO_TRL.source_record_id
FROM
sq_STG_CLMF_CLM_NO_TRL
);


-- Component jnr_TRIGGER_STAGING, Type JOINER 
CREATE OR REPLACE TEMPORARY TABLE jnr_TRIGGER_STAGING AS
(
SELECT
exp_HOLD_DATA.out_MRI_CNT as MRI_COUNT,
exp_HOLD_DATA.out_DUMMY_mstr as out_DUMMY_mstr,
exp_HOLD_STAGING_DATA.CLM_COUNT as CLM_COUNT,
exp_HOLD_STAGING_DATA.out_DUMMY_dtl as out_DUMMY_dtl,
row_number() over (order by 1) AS source_record_id
FROM
exp_HOLD_DATA
INNER JOIN exp_HOLD_STAGING_DATA ON exp_HOLD_STAGING_DATA.out_DUMMY_dtl = exp_HOLD_DATA.out_DUMMY_mstr
);


-- Component exp_HOLD_PARAMETER_VALUES, Type EXPRESSION 
CREATE OR REPLACE TEMPORARY TABLE exp_HOLD_PARAMETER_VALUES AS
(
SELECT
jnr_TRIGGER_STAGING.MRI_COUNT as MRI_COUNT,
jnr_TRIGGER_STAGING.CLM_COUNT as CLM_COUNT,
jnr_TRIGGER_STAGING.MRI_COUNT - jnr_TRIGGER_STAGING.CLM_COUNT as out_REJ_CNT,
CASE WHEN ( TO_NUMBER(jnr_TRIGGER_STAGING.MRI_COUNT) = TO_NUMBER(jnr_TRIGGER_STAGING.CLM_COUNT) ) THEN 0 ELSE 1 END as var_CHECK,
CASE WHEN var_CHECK = 0 THEN :TABLE_NM || '' - AUDIT PASSED FOR RECORD COUNT'' ELSE :TABLE_NM || '' - AUDIT FAILED FOR RECORD COUNT'' END as out_ECTL_MSG,
:PMMappingName as out_PRGM_NM,
:ACT_PROJ_ID as out_ECTL_PROJ_ID,
:BATCH_ACTIVE_IND as out_ACTIVE_IND,
:TABLE_NM as out_TABLE_NM,
:ACT_PROJ_ID as IN_ACT_PROJ_ID,
:BATCH_ACTIVE_IND as IN_BATCH_ACTIVE_IND,
''m_STG_FIN_CLM'' IN_PRGM_NM,
null IN_TABLE_NM,
CURRENT_TIMESTAMP as out_ECTL_ORIG_TS,
jnr_TRIGGER_STAGING.source_record_id
FROM
jnr_TRIGGER_STAGING
);


-- Component mplt_LKP_ECTL_BATCH_PRGM_VALIDATION_CORE, Type MAPPLET 
--MAPPLET NOT REGISTERED: mplt_LKP_ECTL_BATCH_PRGM_VALIDATION_CORE, mapplet instance mplt_LKP_ECTL_BATCH_PRGM_VALIDATION_CORE;
call mplt_LKP_ECTL_BATCH_PRGM_VALIDATION_CORE(''exp_HOLD_PARAMETER_VALUES'');


-- Component exp_HOLD_ALL_FILEDS, Type EXPRESSION 
CREATE OR REPLACE TEMPORARY TABLE exp_HOLD_ALL_FILEDS AS
(
SELECT
exp_HOLD_PARAMETER_VALUES.MRI_COUNT as MRI_COUNT,
exp_HOLD_PARAMETER_VALUES.CLM_COUNT as CLM_COUNT,
exp_HOLD_PARAMETER_VALUES.out_ECTL_MSG as out_ECTTL_MSG,
mplt_LKP_ECTL_BATCH_PRGM_VALIDATION_CORE.out_ECTL_PRGM_ID as out_ECTL_PRGM_ID,
mplt_LKP_ECTL_BATCH_PRGM_VALIDATION_CORE.out_ECTL_BATCH_ID as out_ECTL_BATCH_ID,
mplt_LKP_ECTL_BATCH_PRGM_VALIDATION_CORE.out_ECTL_TABLE_ID as out_ECTL_TABLE_ID,
exp_HOLD_PARAMETER_VALUES.out_ECTL_ORIG_TS as out_ECTL_ORIG_TS,
0 as out_ECTL_DEL_UPD_REJ_CNT,
exp_HOLD_PARAMETER_VALUES.out_REJ_CNT as out_REJ_CNT,
exp_HOLD_PARAMETER_VALUES.source_record_id
FROM
exp_HOLD_PARAMETER_VALUES
INNER JOIN mplt_LKP_ECTL_BATCH_PRGM_VALIDATION_CORE ON exp_HOLD_PARAMETER_VALUES.source_record_id = mplt_LKP_ECTL_BATCH_PRGM_VALIDATION_CORE.source_record_id
);


-- Component ECTL_AUDIT_LOG_INS, Type TARGET 
INSERT INTO DB_T_CTRL_FIN_PROD.ECTL_AUDIT_LOG
(
ECTL_BATCH_ID,
ECTL_PRGM_ID,
ECTL_TABLE_ID,
ECTL_SRC_ROW_CNT,
ECTL_TRGT_INS_CNT,
ECTL_TRGT_UPD_CNT,
ECTL_TRGT_DEL_CNT,
ECTL_TRGT_REJ_CNT,
ECTL_MESSAGE_TXT,
ECTL_ORIG_INS_TS
)
SELECT
exp_HOLD_ALL_FILEDS.out_ECTL_BATCH_ID as ECTL_BATCH_ID,
exp_HOLD_ALL_FILEDS.out_ECTL_PRGM_ID as ECTL_PRGM_ID,
exp_HOLD_ALL_FILEDS.out_ECTL_TABLE_ID as ECTL_TABLE_ID,
exp_HOLD_ALL_FILEDS.MRI_COUNT as ECTL_SRC_ROW_CNT,
exp_HOLD_ALL_FILEDS.CLM_COUNT as ECTL_TRGT_INS_CNT,
exp_HOLD_ALL_FILEDS.out_ECTL_DEL_UPD_REJ_CNT as ECTL_TRGT_UPD_CNT,
exp_HOLD_ALL_FILEDS.out_ECTL_DEL_UPD_REJ_CNT as ECTL_TRGT_DEL_CNT,
exp_HOLD_ALL_FILEDS.out_REJ_CNT as ECTL_TRGT_REJ_CNT,
exp_HOLD_ALL_FILEDS.out_ECTTL_MSG as ECTL_MESSAGE_TXT,
exp_HOLD_ALL_FILEDS.out_ECTL_ORIG_TS as ECTL_ORIG_INS_TS
FROM
exp_HOLD_ALL_FILEDS;


-- PIPELINE START FOR 2

-- Component sq_ECTL_AUDIT_LOG, Type SOURCE 
CREATE OR REPLACE TEMPORARY TABLE sq_ECTL_AUDIT_LOG AS
(
SELECT /* adding column aliases to ensure proper downstream column references */
$1 as ECTL_BATCH_ID,
$2 as ECTL_PRGM_ID,
$3 as ECTL_TABLE_ID,
$4 as ECTL_TRGT_REJ_CNT,
$5 as source_record_id
FROM (
SELECT SRC.*, row_number() over (order by 1) AS source_record_id FROM (
SELECT ECTL_BATCH_ID,ECTL_PRGM_ID,ECTL_TABLE_ID  , ECTL_TRGT_REJ_CNT FROM DB_T_CTRL_FIN_PROD.ECTL_AUDIT_LOG WHERE ECTL_BATCH_ID =(SELECT ECTL_BATCH_ID FROM DB_T_CTRL_FIN_PROD.ECTL_BATCH_INFO WHERE ECTL_PROJ_ID = :ACT_PROJ_ID AND ECTL_ACTIVE_IND =:BATCH_ACTIVE_IND) AND ECTL_PRGM_ID = (SELECT ECTL_PRGM_ID FROM DB_T_CTRL_FIN_PROD.ECTL_PRGM_INFO WHERE ECTL_PRGM_NM =:PMMappingName) AND ECTL_TABLE_ID =(SELECT ECTL_TABLE_ID FROM DB_T_CTRL_FIN_PROD.ECTL_TABLE_XREF WHERE ECTL_TABLE_NM =:TABLE_NM)
) SRC
)
);


-- Component exp_CHECK, Type EXPRESSION 
CREATE OR REPLACE TEMPORARY TABLE exp_CHECK AS
(
SELECT
''SUCCESS'' as out_SUCCESS,
CASE WHEN ( sq_ECTL_AUDIT_LOG.ECTL_TRGT_REJ_CNT <> 0 ) THEN 
null --RAISE_ERROR(''AUDIT BALANCING FAILED FOR '' || :TABLE_NM) 
ELSE 
null --$3 
END as var_CHECK,
sq_ECTL_AUDIT_LOG.ECTL_PRGM_ID as ECTL_PRGM_ID,
sq_ECTL_AUDIT_LOG.ECTL_TABLE_ID as ECTL_TABLE_ID,
sq_ECTL_AUDIT_LOG.ECTL_BATCH_ID as ECTL_BATCH_ID,
sq_ECTL_AUDIT_LOG.source_record_id
FROM
sq_ECTL_AUDIT_LOG
);


-- Component fil_SUCCESS, Type FILTER 
CREATE OR REPLACE TEMPORARY TABLE fil_SUCCESS AS
(
SELECT
exp_CHECK.out_SUCCESS as out_SUCCESS,
exp_CHECK.ECTL_PRGM_ID as ECTL_PRGM_ID,
exp_CHECK.ECTL_TABLE_ID as ECTL_TABLE_ID,
exp_CHECK.ECTL_BATCH_ID as ECTL_BATCH_ID,
exp_CHECK.source_record_id
FROM
exp_CHECK
WHERE exp_CHECK.out_SUCCESS <> ''SUCCESS''
);


-- Component ECTL_AUDIT_LOG_ABORT, Type TARGET 
INSERT INTO DB_T_CTRL_FIN_PROD.ECTL_AUDIT_LOG
(
ECTL_BATCH_ID,
ECTL_PRGM_ID,
ECTL_TABLE_ID,
ECTL_MESSAGE_TXT
)
SELECT
fil_SUCCESS.ECTL_BATCH_ID as ECTL_BATCH_ID,
fil_SUCCESS.ECTL_PRGM_ID as ECTL_PRGM_ID,
fil_SUCCESS.ECTL_TABLE_ID as ECTL_TABLE_ID,
fil_SUCCESS.out_SUCCESS as ECTL_MESSAGE_TXT
FROM
fil_SUCCESS;


-- PIPELINE END FOR 2

END; ';